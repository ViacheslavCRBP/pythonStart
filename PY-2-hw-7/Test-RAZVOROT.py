# Разворот массива через функцию revers

# Алгоритм сортировки TIMSORT   .sort()

#  сложность алгоритма TIMSORT:
#  О(n log n))  - очень хорошая
#  стабильность: устойчивая (два одинаковых
#  элемента сохранят порядок относительно друг друга)
#  Тип (категория): Гибридная (вставками + слиянием)
#  Потребление памяти:  О(n) (память на хранение массива и столько же для копии)


#  Алгоритм сортировки Быстрая ХОАРА:
#  Выбираем опорный элемент (pivot) - первый.., последний... или случайный.
#  Сравниваем элементы массива с опорным и переставляем так, чтобы
#  разбить массив на три отрезка: меньше, равные, бОльшие.
#  Для отрезков меньшие и бОльшие рекурсивно выполнить сортировку.

import random

size = 10
array = [i for i in range(size)]
random.shuffle(array)  # метод shuffle() перемешал значения в array
print(array)
print('*' * 50)

def revers(array):
    for i in range(len(array) // 2):  # переменная будет
# проверять элементы от начала до середины массива. Если
# количество элементов будет нечетное, то средний элемент
# трогать не будем - он останется на месте.
        array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]
# меняется местами пара элементов, расположенных зеркально относительно середины массива

revers(array)
print(array)


# Встроенные в PY функции разворота и сортировкаи
array.reverse()
print(array)

array.sort()
print(array)

array.sort(reverse=True)
print(array)

print('*' * 50)
# генерируем случайный кортеж и попробуем сортировать его:
t = tuple(random.randint(0, 100) for _ in range(size))
print(t)

# коротеж не сортируется!  НО можно через список и обратно:
t = tuple(sorted(t, reverse=True))
print(t)
