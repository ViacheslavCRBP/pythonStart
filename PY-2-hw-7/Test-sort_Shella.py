#  Сортировка Шелла:

#  сложность алгоритма:
#  О(n**2) "О от n в квадрате"  - в худшем случае
#  О(n(log n**2))  - в лучшем времени  (хорошая!)
#  О(n**3/2)   - в лучшем времени - зависит от шага

#  эффективна лишь если в массиве менее 4.000 элементов!

#  стабильность: НЕустойчивая #  (два одинаковых
#  элемента НЕ сохранят порядок относительно друг друга)
#  Тип (категория): вставками
#  Потребление памяти: не требуется доп.память.

#  Алгоритм сортировки Шелла:
#  Выбираем шаг для сравнения элементов
#  Сравниваем последовательно элементы массива, находящиеся
#  один от другого на расстоянии шага
#  уменьшаем шаг и повторяем сравнение...

#  inc = [1, 4, 10, 23, 57, 132, 301, 701, 1750]  - лучший набор шагов!

import random

size = 10
array = [i for i in range(size)]
random.shuffle(array)  # метод shuffle() перемешал значения в array
print(array)
print('*' * 50)

def shell_sort(array):
    assert len(array) < 4000, 'Массив слишком большой. Используйте другой тип сортировки'
    def new_increment(array):
        inc = [1, 4, 10, 23, 57, 132, 301, 701, 1750]
        while len(array) <= inc[-1]:    # исключим шаги, которые больше длины массива
                    #  пока длина массива меньше или равна
                    # последнему элементу списка шагов,
            inc.pop()   # будем удалять последний элемент
        while len(inc) > 0:
            yield inc.pop()  #  пока в списке есть значения,
            # возвращаем последнее значение

    for increment in new_increment(array):
        for i in range(increment, len(array)):
            for j in range(i, increment - 1, -increment):
                if array[j - increment] <= array[j]:
                    break
                array[j], array[j - increment] =  array[j - increment], array[j]
                print(array)


shell_sort(array)
print(array)