#  Сортировка Быстрая ХОАРА  (QUICK):

#  сложность алгоритма:
#  О(n**2) "О от n в квадрате"  - в худшем случае,
#  при неудачном наборе входных значений
#  О(n log n))  - в лучшем времени  (очень хорошая!)

#  стабильность: НЕустойчивая #  (два одинаковых
#  элемента НЕ сохранят порядок относительно друг друга)
#  Тип (категория): ОБМЕННАЯ (как пузырьком)
#  Потребление памяти:  О(n) (память на хранение массива
#  и столько же для копии)   /не требуется доп.память.

#  Алгоритм сортировки Быстрая ХОАРА:
#  Выбираем опорный элемент (pivot) - первый.., последний... или случайный.
#  Сравниваем элементы массива с опорным и переставляем так, чтобы
#  разбить массив на три отрезка: меньше, равные, бОльшие.
#  Для отрезков меньшие и бОльшие рекурсивно выполнить сортировку.

import random

size = 10
array = [i for i in range(size)]
random.shuffle(array)  # метод shuffle() перемешал значения в array
print(array)
print('*' * 50)

def quick_sort(array):

    if len(array) <= 1:   # базовый случай - если длина массива <= 1, то возвращаем массив
        return array
    #  опорный элемент выбираем случайным образом:
    pivot = random.choice(array)
    #  далее создаем три пустых списка:
    small_ar = []
    medium_ar = []
    large_ar = []

    for item in array:  # циклом перебираем все элементы массива
        if item < pivot:
            small_ar.append(item)   # если элем меньше опорного,
            # то добавляем его в список меньших
        elif item > pivot:  # если элем больше опорного,
            # то добавляем его в список больших
            large_ar.append(item)
        elif item == pivot:  # если элем равен опорному,
            # то добавляем его в список равных
            medium_ar.append(item)
        else:
            raise Exception('Непредвиденное значение')
        #  посмотрим промежуточные значения:
    print(small_ar, medium_ar, large_ar)
    # возвращаем отсортированный список:
    return quick_sort(small_ar) + medium_ar + quick_sort(large_ar)

array_new = quick_sort(array)
print(array_new)
